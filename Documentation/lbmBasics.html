<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="generator" content="scholpandoc">
  <meta name="viewport" content="width=device-width">
  
  <meta name="author" content="Ganesh Vijayakumar">
  <meta name="dcterms.date" content="2015-10-09">
  <title>My understanding of the Lattice Boltzmann Method</title>
  <style type="text/css">code{white-space: pre;}</style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.7.1/modernizr.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.js"></script>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="css/ScholarlyMarkdown-BS3.css">
</head>
<body>
<div class="scholmd-container">
<div class="scholmd-main">
<div class="scholmd-content">
<header>
<h1 class="scholmd-title">My understanding of the Lattice Boltzmann Method</h1>
<div class="scholmd-author">
Ganesh Vijayakumar
</div>
<div class="scholmd-date">09 Oct 2015</div>
</header>
<h1 id="basic-boltzmann-gas-concepts">Basic Boltzmann Gas concepts</h1>
<p>The first concept to understand is that the gas is described as number of molecules interacting with one another only through collisions. A number density function <span class="scholmd-citation" data-cites="Gombosi1994">[1]</span> is defined as the number of molecules <span class="math scholmd-math-inline">\(\Delta^3 N\)</span> in a volume <span class="math scholmd-math-inline">\(\Delta^3 x\)</span> around <span class="math scholmd-math-inline">\(\vec{x}\)</span> at a given time <span class="math scholmd-math-inline">\(t\)</span>. 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation*}
n(\vec{x},t) = \lim_{\Delta^3 x \to 0} \frac{\Delta^3 N(\vec{x},t)}{\Delta^3 x}
\end{equation*}
\]</span>
 This is probably related to the density through a scaling factor 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation*}
\rho(\vec{x},t) = n(\vec{x},t) \times \frac{MolecularWeight}{AvogradoNumber}
\end{equation*}
\]</span>
 The Boltzmann theory further splits the number density into a distribution function in a phase space that includes the velocity of the molecules. So <span class="math scholmd-math-inline">\(f(\vec{x}, \vec{v}, t)\)</span> is distribution function of the number of molecules <span class="math scholmd-math-inline">\(\Delta^3 N\)</span> in a volume <span class="math scholmd-math-inline">\(\Delta^3 x\)</span> around <span class="math scholmd-math-inline">\(\vec{x}\)</span> and in a certain “velocity-volume” <span class="math scholmd-math-inline">\(\Delta^3 v\)</span> around a velocity <span class="math scholmd-math-inline">\(\vec{v}\)</span> at a given time <span class="math scholmd-math-inline">\(t\)</span> 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation*}
f(\vec{x},\vec{v},t) = \lim_{\Delta^3 x, \Delta^3 v \to 0} \frac{\Delta^3 N(\vec{x},\vec{v},t)}{\Delta^3 x \; \Delta^3 v}
\end{equation*}
\]</span>
 <span class="math scholmd-math-inline">\(f(\vec{x}, \vec{v}, t)\)</span> is connected to <span class="math scholmd-math-inline">\(n(\vec{x}, t)\)</span> through integration over all possible velocity magnitudes and directions at the same location <span class="math scholmd-math-inline">\(\vec{x}\)</span> 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation*}
n(\vec{x},t) = \iiint_{\infty} f(\vec{x},\vec{v},t) d^3v
\end{equation*}
\]</span>
 I borrow the rest of this material from Sukop and Thorne <span class="scholmd-citation" data-cites="Sukop2006">[2]</span>. Let’s say there’s an external force acting on the molecules  <span class="math scholmd-math-inline">\((\vec{F} \ll \textrm{Intermolecular forces})\)</span>. If there are no collision, The molecules at <span class="math scholmd-math-inline">\((\vec{x},\vec{v},t)\)</span> will get moved to a new position in the phase space <span class="math scholmd-math-inline">\((\vec{x} + \vec{dx}, \vec{v} + \vec{dv},t \; + \;dt)\)</span> such that <span class="math scholmd-math-inline">\(\vec{dv} = (\vec{F}/\rho)dt\)</span> and <span class="math scholmd-math-inline">\(\vec{dx} = \vec{v} \; dt\)</span>. Through the <strong>streaming process</strong>, the particle distribution function <span class="math scholmd-math-inline">\(f\)</span> also gets streamed to the new location such that 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation*}
f(\vec{x} + \vec{dx}, \vec{v} + \vec{dv},t \; + \;dt) \; \vec{dx} \; \vec{dv} = f(\vec{x}, \vec{v},t) \; \vec{dx} \; \vec{dv}
\end{equation*}
\]</span>
 I have a <strong>big</strong> question here. Can’t particles arrive at <span class="math scholmd-math-inline">\((\vec{x} + \vec{dx}, \vec{v} + \vec{dv},t \; + \;dt)\)</span> from somewhere else in the phase space? I’m pretty sure it’s not impossible. According to everything I’ve read so far, they just write this for the case of no collisions. I say that even with no collisions and well.. even no forces, it’s possible for molecules from two different positions to come to one place. May be they’ll collide there, but no collision until then. Got to figure out the reasoning behind this.</p>
<p>Moving on, there are collisions that result in some phase points starting at <span class="math scholmd-math-inline">\((\vec{x},\vec{v},t)\)</span> and not arriving at <span class="math scholmd-math-inline">\((\vec{x} + \vec{dx}, \vec{v} + \vec{dv},t \; + \;dt)\)</span> and some not starting at <span class="math scholmd-math-inline">\((\vec{x},\vec{v},t)\)</span> and arriving there (this probably answers the question above). 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation*}
\begin{aligned}
\textrm{Number of molecules that do not arrive at } (\vec{x} + \vec{dx}, \vec{v} + \vec{dv},t \; + \;dt) \textrm{ due to collision } &amp; \longrightarrow \Gamma^- \vec{dx} \; \vec{dv} \; dt \\
\textrm{Number of molecules that do arrive at } (\vec{x} + \vec{dx}, \vec{v} + \vec{dv},t \; + \;dt) \textrm{ from somewhere else } &amp; \longrightarrow \Gamma^+ \vec{dx} \; \vec{dv} \; dt \\
\end{aligned}
\end{equation*}
\]</span>
 Combining the streaming process and the model for collisions, we get the Boltzmann equation 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation*}
\begin{aligned}
f(\vec{x} + \vec{dx}, \vec{v} + \vec{dv},t \; + \;dt) \; \vec{dx} \; \vec{dv} &amp;= f(\vec{x}, \vec{v},t) \; \vec{dx} \; \vec{dv} + (\Gamma^+ - \Gamma^-) \vec{dx} \; \vec{dv} \; dt \\
\left ( f(\vec{x}, \vec{v},t) + \vec{dx} \cdot \nabla_x f + \vec{dv} \cdot \nabla_v f + \frac{\partial f}{\partial t} dt \right ) \; \vec{dx} \; \vec{dv} &amp;= f(\vec{x}, \vec{v},t) \; \vec{dx} \; \vec{dv} + (\Gamma^+ - \Gamma^-) \vec{dx} \; \vec{dv} \; dt \\
\frac{\partial f}{\partial t} + \vec{v} \cdot \nabla_x f + \frac{\vec{F}}{\rho} \cdot \nabla_v f &amp;= (\Gamma^+ - \Gamma^-)
\end{aligned}
\end{equation*}
\]</span>
 The term <span class="math scholmd-math-inline">\((\Gamma^+ - \Gamma^-)\)</span> is usually modeled as a return to equilibrium using the Bhatnagar-Grossman-Krook (BGK) collision operator with a single relaxation time scale <span class="math scholmd-math-inline">\(\tau\)</span>.</p>
<h1 id="application-to-the-lattice-boltzmann-method">Application to the Lattice Boltzmann Method</h1>
<p>The first thing that nobody seems to mention regarding the Lattice Boltzmann Method is that they go ahead and assume that <span class="math scholmd-math-inline">\(f\)</span> already contains the scaling factor such that 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation*}
\rho(\vec{x},t) = \iiint_{\infty} f(\vec{x},\vec{v},t) d^3v
\end{equation*}
\]</span>
 Instead of a continuum of possible positions and velocity for the molecules, the positions are limited to a set of points on a lattice and the velocities are restricted to a set of magnitudes and directions. The set of possible velocities are connected to the lattice and the time step. The D2Q9 and D3Q15 are very commonly used in 2D and 3D simulations respectively. The basic lattice distance <span class="math scholmd-math-inline">\(\delta x\)</span> is set to 1 as is the time step <span class="math scholmd-math-inline">\(\delta t\)</span>. Thus, the <em>grid speed</em> is <span class="math scholmd-math-inline">\(c = \delta x / \delta t = 1\)</span>. Of course, there conversion factors for each quantity like <span class="math scholmd-math-inline">\(\delta x, \delta t, c\)</span> to their corresponding physical values. Figure <span class="scholmd-crossref"><a href="#latticeDiscretization2D3D">1</a></span> shows the two basic lattice models used are the D2Q9 version for 2D and D3Q15 for 3D.</p>
<figure class="scholmd-float scholmd-figure" id="latticeDiscretization2D3D">
<div class="scholmd-float-content"><figure class="scholmd-subfig" style="display: inline-block; width: ">
<img src="d2q9d3q15.png" />
</figure></div>
<div class="scholmd-float-caption"><figcaption><span class="scholmd-caption-head"><span class="scholmd-caption-head-prefix">Figure</span><span class="scholmd-caption-head-label">1</span></span><span class="scholmd-caption-text">Illustrations of the lattice and directional densities on a D2Q9 (left) and D3Q15 (right) arrangement (from <span class="scholmd-citation" data-cites="Nourgaliev2003117">[3]</span>).</span></figcaption></div>
</figure>
<p>I now explain how the choice of the discrete velocity vectors are tied to the grid and the time step. In Figure <span class="scholmd-crossref"><a href="#latticeDiscretization2D3D">1</a></span>, the red vectors are of unit distance in lattice units in both D2Q9 and D3Q15 models. The corresponding velocity vectors are lattice unit per time step. The choice of the velocity vectors is done such that that any molecule with that velocity at that point will get <em>streamed</em> to the first neighboring node along the velocity direction in one time step. Thus the green distance and velocity vectors are <span class="math scholmd-math-inline">\(\sqrt{2}\)</span> lattice units in the D2Q9 model and <span class="math scholmd-math-inline">\(\sqrt{3}\)</span> units in the D3Q15 model. Thus the continuous particle distribution <span class="math scholmd-math-inline">\(f(\vec{x}, \vec{v}, t)\)</span> becomes the discrete <em>directional densities</em> <span class="math scholmd-math-inline">\(f_{\alpha}(\vec{x},t), \, \alpha=1,b\)</span> at each lattice point/node, where <span class="math scholmd-math-inline">\(b\)</span> is the number of directions used in the lattice model (9 for the D2Q9 and 15 for the D3Q15 models). The macroscopic properties density (<span class="math scholmd-math-inline">\(\rho\)</span>) and velocity (<span class="math scholmd-math-inline">\(\vec{v}\)</span>) are recovered from the directional densities as 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation*}
\begin{aligned}
\rho(\vec{x},t) &amp;= \Sigma_{\alpha = 1}^b f_{\alpha} (\vec{x},t) \\
\rho(\vec{x},t) \; \vec{v}(\vec{x},t) &amp;= \Sigma_{\alpha = 1}^b f_{\alpha} (\vec{x},t) \hat{e}_{\alpha}
\end{aligned}
\end{equation*}
\]</span>
 The pressure is recovered through the equation of state, where 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation*}
P(\vec{x},t) = \rho(\vec{x},t) c_s^2 
\end{equation*}
\]</span>
 where <span class="math scholmd-math-inline">\(c_s\)</span> is the speed of sound in lattice units <span class="math scholmd-math-inline">\(c_s = \sqrt{RT} = \sqrt{1/3}\)</span> in lattice units. I wonder why the ratio of specific heats <span class="math scholmd-math-inline">\(\gamma\)</span> is missing from the expression for the speed of sound. In any case, this tells us that the LBM method is essentially a compressible method.</p>
<p>The basic LBM method for the momentum and continuity equations thus becomes 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation*}
f_{\alpha}(\vec{x} + \hat{e}_{\alpha} \; \delta t,t + \delta t) = f_{\alpha} (\vec{x},t) - \frac{1}{\tau} \left [ f_{\alpha} (\vec{x},t) - f_{\alpha}^{eq} (\vec{x},t) \right ]
\end{equation*}
\]</span>
 The time advance in the LBM method is carried out algorithmically in two steps, viz.,</p>
<ol type="1">
<li>Collision step</li>
</ol>
<p>
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation}
\label{eq:LBMcollision}
\hat{f}_{\alpha}(\vec{x}, t) = f_{\alpha} (\vec{x},t) - \frac{1}{\tau} \left [ f_{\alpha} (\vec{x},t) - f_{\alpha}^{eq} (\vec{x},t) \right ]
\end{equation}
\]</span>
</p>
<ol start="2" type="1">
<li>Streaming step 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation}
\label{eq:LBMstreaming}
f_{\alpha}(\vec{x} + \hat{e}_{\alpha} \; \delta t,t + \delta t) = \hat{f}_{\alpha} (\vec{x},t) 
\end{equation}
\]</span>
</li>
</ol>
<p>where <span class="math scholmd-math-inline">\(\hat{f}_{\alpha} (\vec{x},t)\)</span> is the <em>post-collision pre-streamed</em> directional densities. The boundary conditions are typically applied on <span class="math scholmd-math-inline">\(\hat{f}\)</span>.</p>
<h2 id="bgk-collision-operator">BGK collision operator</h2>
<p>The rate of relaxation towards equilibrium is typically a measure of the rate of molecular mixing and is hence proportional to the kinematic viscosity. In lattice units 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation*}
\nu = (2 \tau - 1) \frac{c \; \delta x}{6}
\end{equation*}
\]</span>
 The viscosity in physical units is matched to the viscosity in lattice units by matching the Reynolds numbers between the physical and lattice units. For numerical stability purposes, the choice of <span class="math scholmd-math-inline">\(\tau\)</span> is designed to be such that the viscosity is positive and hence <span class="math scholmd-math-inline">\(\tau &gt; 0.5\)</span>. The farther away it is from <span class="math scholmd-math-inline">\(0.5\)</span>, the more stable the simulation is expected to be.</p>
<p>In the low Mach number limit, the equilibrium distribution function <span class="math scholmd-math-inline">\(f^{eq}\)</span> is written as 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation*}
f^{eq}_{\alpha} (\vec{x},t) = w_{\alpha} \rho(\vec{x},t) \left [ 1 + 3 \frac{\hat{e}_{\alpha} \cdot \vec{v}}{c^2} + \frac{9}{2} \frac{(\hat{e}_{\alpha} \cdot \vec{v})^2 }{c^4} - \frac{3}{2} \frac{(\vec{v} \cdot \vec{v})^2}{c^2}  \right ]
\end{equation*}
\]</span>
 For the D2Q9 model, 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation*}
w_{\alpha} =  \left \{ \begin{aligned} 4/9 &amp; \, \alpha = 0 \\ 1/9 &amp; \, \alpha = 1,3,5,7 \\ 1/36 &amp; \, \alpha = 2,4,6,8 \end{aligned} \right.
\end{equation*}
\]</span>
 The rest of the stuff to be written up are</p>
<h1 id="conversion-of-lattice-units-to-physical-units">Conversion of lattice units to physical units</h1>
<p>The code converts the physical units to lattice units as follows in <a href="">Geometry.f90</a></p>
<pre class="sourceCode fortran"><code class="sourceCode fortran"><span class="co">! Define the lattice &lt;=&gt; physical conversion factors</span>
<span class="kw">IF</span>(domaintype <span class="kw">.EQ.</span> <span class="dv">0</span>) <span class="kw">THEN</span>
xcf <span class="kw">=</span> (<span class="fl">0.5_lng</span><span class="kw">*</span>D)<span class="kw">/</span>(nx<span class="kw">-</span><span class="dv">1_lng</span>)   <span class="co">! length conversion factor: x-direction</span>
ycf <span class="kw">=</span> (<span class="fl">0.5_lng</span><span class="kw">*</span>D)<span class="kw">/</span>(ny<span class="kw">-</span><span class="dv">1_lng</span>)   <span class="co">! length conversion factor: y-direction</span>
<span class="kw">ELSE</span>
<span class="co">! begin Balaji added</span>
xcf <span class="kw">=</span> (<span class="fl">1.0_lng</span><span class="kw">*</span>D)<span class="kw">/</span>(nx<span class="kw">-</span><span class="dv">1_lng</span>)   <span class="co">! length conversion factor: x-direction</span>
ycf <span class="kw">=</span> (<span class="fl">1.0_lng</span><span class="kw">*</span>D)<span class="kw">/</span>(ny<span class="kw">-</span><span class="dv">1_lng</span>)   <span class="co">! length conversion factor: y-direction</span>
<span class="co">! end Balaji added</span>
<span class="kw">ENDIF</span>

zcf <span class="kw">=</span> L<span class="kw">/</span>nz                     <span class="co">! length conversion factor: z-direction</span>
tcf <span class="kw">=</span> nuL<span class="kw">*</span>((xcf<span class="kw">*</span>xcf)<span class="kw">/</span>nu)       <span class="co">! time conversion factor</span>
dcf <span class="kw">=</span> den<span class="kw">/</span>denL                 <span class="co">! density conversion factor</span>
vcf <span class="kw">=</span> xcf<span class="kw">/</span>tcf                  <span class="co">! velocity conversion factor</span>
pcf <span class="kw">=</span> cs<span class="kw">*</span>cs<span class="kw">*</span>vcf<span class="kw">*</span>vcf            <span class="co">! pressure conversion factor</span>

<span class="co">! Determine the number of time steps to run</span>
nt <span class="kw">=</span> <span class="kw">ANINT</span>((nPers<span class="kw">*</span>Tmix)<span class="kw">/</span>tcf)</code></pre>
<p>In human readable form, this becomes 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation*}
\begin{aligned}
x_{cf} &amp;= \frac{D}{n_x-1} \\
y_{cf} &amp;= \frac{D}{n_y-1} \\
z_{cf} &amp;= \frac{L}{nz} \\
t_{cf} &amp;= \nu_L \frac{x_{cf} \; x_{cf}}{\nu} \\
\rho_{cf} &amp;= \frac{\rho}{\rho_L} \\
v_{cf} &amp;= \frac{x_{cf}}{t_{cf}}
\end{aligned}
\end{equation*}
\]</span>
 The quantities with <span class="math scholmd-math-inline">\(f_L\)</span> are in lattice units. For e.g <span class="math scholmd-math-inline">\(\rho_L = 1.0\)</span> is the density in lattice units and <span class="math scholmd-math-inline">\(\nu_L\)</span> is the viscosity in lattice units defined in <code>LBM.f90</code> as <span class="math scholmd-math-inline">\(\nu_L = (2 \tau - 1)/6\)</span>.</p>
<pre class="sourceCode fortran"><code class="sourceCode fortran">nuL <span class="kw">=</span> (<span class="fl">2.0_dbl</span><span class="kw">*</span>tau <span class="kw">-</span> <span class="fl">1.0_dbl</span>)<span class="kw">/</span><span class="fl">6.0_dbl</span></code></pre>
<h2 id="example">Example</h2>
<p>For the conditions in the <code>input.txt</code> given by Balaji, 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation*}
\begin{aligned}
\tau &amp;= 1.0 \\
\nu_L &amp;= \frac{2-1}{6} = 0.16667 \\
n_x = n_y &amp;= 81 \\
D &amp;= 0.012m \\
x_{cf} = y_{cf} &amp;= 1.5 \times 10^{-4}m \\
L &amp;= 0.024m \\
n_z &amp;= 160 \\
z_{cf} &amp;= 1.5 \times 10^{-4}m \\
\nu &amp;= 2.4 \times 10^{-6} m^2/s \\
t_{cf} &amp;= 0.1667 \frac{1.5 \times 10^{-4} \times 1.5 \times 10^{-4}}{2.4 \times 10^{-6}} = 1.5628 \times 10^{-3}s \\
v_{cf} &amp;= \frac{1.5 \times 10^{-4}m}{ 1.5628 \times 10^{-3}} = 0.09598 m/s
\end{aligned}
\end{equation*}
\]</span>
 The motility parameters are 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation*}
\begin{aligned}
s_1 &amp;= 0.004m/s \textrm{ Wave speed for Peristalsis}\\
D &amp;= 0.012m \textrm{ Max diameter}\\
num_{w1} &amp;= 1 \textrm{ Number of waves in the domain} \\
\lambda_1 &amp;= \frac{L}{num_{w1}} = 0.024m \textrm{ Wavelength of peristaltic wave}\\
Re_1 &amp;= \frac{s_1 (0.5 \; D)}{ \nu} \frac{0.5 \; D}{\lambda_1} = \frac{0.004 \times 0.006}{2.4 \times 10^{-6}} \frac{0.006}{0.024} = 2.5 \\
\end{aligned}
\end{equation*}
\]</span>
 Trying to estimate Reynolds number in lattice units 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation*}
\begin{aligned}
\textrm{Wave speed in lattice units } &amp;=  s_1/v_{cf} = 0.004/0.09598 = 0.040568 \\
\textrm{Radius in lattice units } &amp;= 40 \\
\textrm{Length in lattice units } &amp;= 160 \\
\textrm{Reynolds number in lattice units } &amp;= \frac{0.040568 \times 40}{0.16667} \frac{40}{160} = 2.434
\end{aligned}
\end{equation*}
\]</span>
 Thus, the Reynolds number in lattice units is made to match up with the one in physical units. I still don’t understand completely as to why the two Reynolds numbers need to match.</p>
<h1 id="boundary-conditions">Boundary conditions</h1>
<h1 id="treatment-of-passive-scalar">Treatment of passive scalar</h1>
<h2 id="scalar-boundary-conditions">Scalar boundary conditions</h2>
<p>The scalar boundary condition is a little different from the typical bounce back boundary conditions because, unlike momentum, scalar does not bounce back from the wall. The wall could have a fixed value of the scalar or a fixed flux or a combination of both. Within the framework of the moment propagation method, the difficulty lies in finding the contribution <span class="math scholmd-math-inline">\(P_k(\vec{x} - \vec{e}_k \, \delta t, t + \delta t)\)</span> at the node adjacent to the wall. We first consider the case of a specified value of scalar at the wall (Dirichlet boundary condition).</p>
<figure class="scholmd-float scholmd-figure" id="fig:scalarBC">
<div class="scholmd-float-content"><figure class="scholmd-subfig" style="display: inline-block; width: 75%">
<img src="./Figures/scalarBoundaryCondition.png" />
</figure></div>
<div class="scholmd-float-caption"><figcaption><span class="scholmd-caption-head"><span class="scholmd-caption-head-prefix">Figure</span><span class="scholmd-caption-head-label">2</span></span><span class="scholmd-caption-text">Node system used in developing the boundary conditions for scalar concentration by Wang et. al. <span class="scholmd-citation" data-cites="Wang2010">[4]</span>.</span></figcaption></div>
</figure>
<p><span class="math scholmd-math-inline">\(A^*\)</span>, <span class="math scholmd-math-inline">\(B^*\)</span> and <span class="math scholmd-math-inline">\(C^*\)</span> are three virtual nodes one lattice apart such that <span class="math scholmd-math-inline">\(A^*\)</span> is the node on the boundary. The scalar boundary condition for a fixed value of the scalar at the boundary involves calculating the contribution <span class="math scholmd-math-inline">\(P_k(\vec{x} - \vec{e}_k \, \delta t, t + \delta t)\)</span> at <span class="math scholmd-math-inline">\(B^*\)</span> and <span class="math scholmd-math-inline">\(C^*\)</span> and extrapolating it to A. This is done in 3 steps as shown below.</p>
<ol type="1">
<li>Estimate the density and particle distribution function in the <span class="math scholmd-math-inline">\(k\)</span> direction at <span class="math scholmd-math-inline">\(A^*\)</span> as 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation*}
\rho_{A^*} = \rho_A  + (\rho_A - \rho_B) q.
\end{equation*}
\]</span>
</li>
</ol>
<p>The particle distribution function (post-collision) at <span class="math scholmd-math-inline">\(A^*\)</span> is split into equilibrium and non-equilibrium parts and evaluate them separately as shown in Eq. <span class="scholmd-crossref"><span class="math scholmd-math-inline">\(\eqref{fAstar}\)</span></span>. 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation}
\label{fAstar}
\begin{aligned}
\hat{f}_{k, A^*} &amp;= f_{k, A^*}^{eq} + f_{k, A^*}^{neq}, \\
\textrm{Based on $\mathbf{u}_w$ wall velocity   } f_{k, A^*}^{eq} &amp;= w_{k} \, \rho_{A^*} \, \left [ 1 + 3 \frac{\vec{e}_{k} \cdot \vec{u}_w}{c^2} + \frac{9}{2} \frac{(\hat{e}_{k} \cdot \vec{u}_w)^2 }{c^4} - \frac{3}{2} \frac{(\vec{u}_w \cdot \vec{u}_w)^2}{c^2}  \right ], \\
\textrm{Based on extrapolation   } f_{k, A^*}^{neq} &amp;= f_{k, A}^{neq} + ( f_{k, A}^{neq} - f_{k, B}^{neq}) q. \\
\end{aligned}
\end{equation}
\]</span>
 2. Calculate the contribution <span class="math scholmd-math-inline">\(P_k(\vec{x} - \vec{e}_k \, \delta t, t + \delta t)\)</span> at <span class="math scholmd-math-inline">\(B^*\)</span> and <span class="math scholmd-math-inline">\(C^*\)</span> as shown in Eq. <span class="scholmd-crossref"><span class="math scholmd-math-inline">\(\eqref{PkAstarBstar}\)</span></span>. While <span class="math scholmd-math-inline">\(\hat{f}_k\)</span>, <span class="math scholmd-math-inline">\(\rho\)</span> and <span class="math scholmd-math-inline">\(\phi\)</span> are calculated at <span class="math scholmd-math-inline">\(A^*\)</span> in Step 1, the corresponding quantities are interpolated to <span class="math scholmd-math-inline">\(B^*\)</span> using the values at <span class="math scholmd-math-inline">\(A\)</span> and <span class="math scholmd-math-inline">\(B\)</span> at time <span class="math scholmd-math-inline">\(t\)</span>. 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation}
\label{PkAstarBstar}
\begin{aligned}
(P_k)_{A^* \rightarrow B^*, t + \delta t} &amp;= \left ( \frac{\hat{f}_k(A^*,t^+)}{\rho(A^*,t^+)} - w_k \Delta^* \right ) \phi(A^*, t) \\
(P_k)_{B^* \rightarrow C^*, t + \delta t} &amp;= \left ( \frac{\hat{f}_k(B^*,t^+)}{\rho(B^*,t^+)} - w_k \Delta^* \right ) \phi(B^*, t)
\end{aligned}
\end{equation}
\]</span>
 3. Calculate the contribution <span class="math scholmd-math-inline">\(P_k(\vec{x} - \vec{e}_k \, \delta t, t + \delta t)\)</span> at <span class="math scholmd-math-inline">\(A\)</span> using linear extrapolation from <span class="math scholmd-math-inline">\(B^*\)</span> and <span class="math scholmd-math-inline">\(C^*\)</span> as 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation*}
P_k(\vec{x} - \vec{e}_k \, \delta t, t + \delta t)_A = (P_k)_{A^* \rightarrow B^*, t + \delta t} + \left [ (P_k)_{A^* \rightarrow B^*, t + \delta t} - (P_k)_{B^* \rightarrow C^*, t + \delta t} \right ] (1 - q).
\end{equation*}
\]</span>
 This procedure is extended to the case with a specified scalar flux at the boundary (Neumann boundary condition).</p>
<h2 id="calculation-of-scalar-flux-at-the-boundary-scalarfluxcalc">Calculation of scalar flux at the boundary #scalarFluxCalc</h2>
<p>When using the moment propagation method for a scalar in LBM, the difference between the scalar streamed to and from the node that is adjacent to the boundary to calculate the mass flux across the boundary. As shown in Eq. <span class="scholmd-crossref"><span class="math scholmd-math-inline">\(\eqref{scalarFluxAcrossBoundary}\)</span></span>, the difference when summed over all the nodes adjacent to the boundary gives the mass flux across the entire boundary. 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation}
\label{scalarFluxAcrossBoundary}
\textrm{Mass flux out of domain} = \sum_{A \in \textrm{all nodes adjacent to boundary}} \left (P_{k&#39;}(\vec{x} - \vec{e}_{k&#39;} \, \delta t, t + \delta t)_A - P_k(\vec{x} - \vec{e}_k \, \delta t, t + \delta t)_A  \right ) \frac{\Delta^3}{t_{cf}} \; mol/s,
\end{equation}
\]</span>
 where <span class="math scholmd-math-inline">\(k\)</span> is the direction going from the node to the boundary, <span class="math scholmd-math-inline">\(k&#39;\)</span> is the mirror image of <span class="math scholmd-math-inline">\(k\)</span>, <span class="math scholmd-math-inline">\(\Delta^3\)</span> is the physical volume surrounding each node and <span class="math scholmd-math-inline">\(t_{cf}\)</span> is the physical time corresponding to one LBM time step.</p>
<h1 id="multi-grid-scheme">Multi-grid scheme</h1>
<p>Yangxing Wang <span class="scholmd-citation" data-cites="Wang2010">[4]</span> and Gino Banco <span class="scholmd-citation" data-cites="Banco2010">[5]</span> had implemented the multiple-grid scheme of Yu, Mei and Shyy <span class="scholmd-citation" data-cites="Yu2002">[6]</span> and extended them to scalars transport using the Moment propagation method. Yangxing’s validation study of the method using the lid driven cavity was in 2D while Banco extended the method to 3D. As of now, we do not have a code that contains the implementation of the multiple grid strategy. This section will describe our understanding of the method as described by Wang et. al. <span class="scholmd-citation" data-cites="Wang2010">[4]</span>, Banco <span class="scholmd-citation" data-cites="Banco2010">[5]</span> and Yu et. al. <span class="scholmd-citation" data-cites="Yu2002">[6]</span>.</p>
<p>The main puupose of the multiple grid scheme is to preseve the required resolution near complicated boundaries without paying the penalty of using the same resolution away from these boundaries. While this strategy could be generalized to a series of smaller and smaller grids until the required resolution is reached, the implementation is discussed only for one level of refinement between a coarse and fine grid. The overlap between the coarse and the fine grids is no more than 1 coarse lattice unit as shown in Figure <span class="scholmd-crossref"><a href="#fig:coarseToFineGridInterface">(3)</a></span>.</p>
<figure class="scholmd-float scholmd-figure" id="fig:coarseToFineGridInterface">
<div class="scholmd-float-content"><figure class="scholmd-subfig" style="display: inline-block; width: 75%">
<img src="./Figures/coarseToFineGridInterface.png" />
</figure></div>
<div class="scholmd-float-caption"><figcaption><span class="scholmd-caption-head"><span class="scholmd-caption-head-prefix">Figure</span><span class="scholmd-caption-head-label">3</span></span><span class="scholmd-caption-text">Interface structure betwee two blocks of different lattice spacing as shown by Yu et. al. <span class="scholmd-citation" data-cites="Yu2002">[6]</span>.</span></figcaption></div>
</figure>
<p>The grid-speed in lattice units is retained between the two grids. The lattice unit distance and the time step between the two grids is of ratio <span class="math scholmd-math-inline">\(m = \delta x_c/\delta x_f\)</span>, where <span class="math scholmd-math-inline">\(c\)</span> and <span class="math scholmd-math-inline">\(f\)</span> indicate the coarse and the fine grids respectively. <span class="math scholmd-math-inline">\(m\)</span> should preferably be an integer, such that the streaming process over 1 coarse grid lattice unit <span class="math scholmd-math-inline">\(\delta x_c\)</span> takes <span class="math scholmd-math-inline">\(m\)</span> lattice time steps in the fine grid. To maintain continuity of viscosity across the grid interface 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation*}
\begin{aligned}
(2 \tau_f - 1) \frac{c \; \delta x_f}{6} &amp; = \nu = (2 \tau_c - 1) \frac{c \; \delta x_c}{6} \\
\rightarrow (2 \tau_f - 1) &amp;= m (2 \tau_c - 1) \\
\rightarrow \tau_f &amp;= \frac{1}{2} + m \left ( \tau_c - \frac{1}{2} \right )
\end{aligned}
\end{equation*}
\]</span>
 Yu et. al. split the directional density distribution at each lattice node into an equilibrium and a non-equilibrium part. This is mathematically represented as 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation*}
\begin{split}
f_{\alpha}(\vec{x},t) = f_{\alpha}^{(eq)}(\vec{x},t) + f_{\alpha}^{(neq)}(\vec{x},t) \\
\end{split}
\end{equation*}
\]</span>
 They argue that, for velocity and density to be continuous across the interface 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation}
\label{eq:rhoVContinuityInterface}
f_{\alpha}^{(eq,c)}(\vec{x},t) = f_{\alpha}^{(eq,f)}(\vec{x},t)
\end{equation}
\]</span>
 They also write a formula to compute the deviatoric stresses from the non-equilibrium part of the directional density in 2D as 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation}
\label{eq:deviatoricStressFromNonEqDirectionalDensity}
\tau_{ij} = \left ( 1 - \frac{1}{2 \tau} \right ) \sum_{\alpha} f_{\alpha}^{(neq)} \left ( \vec{e}_{\alpha i} \vec{e}_{\alpha j} - \frac{1}{2} \vec{e}_{\alpha} \cdot \vec{e}_{\alpha} \delta_{ij} \right )
\end{equation}
\]</span>
 Hence for the deviatoric stresses to be continuous across the interface, they argue that 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation}
\label{eq:continuityDeviatoricStress}
\begin{aligned}
\left ( 1 - \frac{1}{2 \tau_c} \right ) f_{\alpha}^{(neq,c)} &amp;= \left ( 1 - \frac{1}{2 \tau_f} \right ) f_{\alpha}^{(neq,f)} \\
\rightarrow f_{\alpha}^{(neq,c)} &amp;= m \frac{\tau_c}{\tau_f} f_{\alpha}^{(neq,f)}
\end{aligned}
\end{equation}
\]</span>
 As a reminder, the collision process is modeled as a return to equilibrium with a single time scale <span class="math scholmd-math-inline">\(\tau\)</span> using the BGK model (see Equation <span class="scholmd-crossref"><span class="math scholmd-math-inline">\(\eqref{eq:LBMcollision}\)</span></span>). Hence, 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation*}
\begin{aligned}
\hat{f}_{\alpha}(\vec{x},t + \delta t) &amp;= \left (1 - \frac{1}{\tau} \right ) f_{\alpha}(\vec{x},t) + \frac{1}{\tau} f_{\alpha}^{(eq)}(\vec{x},t) \\
&amp;= \left (1 - \frac{1}{\tau} \right ) \left [ f_{\alpha}^{(eq)}(\vec{x},t) + f_{\alpha}^{(neq)}(\vec{x},t) \right ] + \frac{1}{\tau} f_{\alpha}^{(eq)}(\vec{x},t)
\end{aligned}
\end{equation*}
\]</span>
 This tells us in a very nice form that the effect of the collision operator is to reduce the contribution of the non-equilibrium directional density as 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation}
\label{eq:LBMcollisionEqNonEq}
\hat{f}_{\alpha} = f_{\alpha}^{(eq)} + \frac{\tau - 1}{\tau}  f_{\alpha}^{(neq)}
\end{equation}
\]</span>
 Using Equation <span class="scholmd-crossref"><span class="math scholmd-math-inline">\(\eqref{eq:LBMcollisionEqNonEq}\)</span></span> for the coarse grid and substituting Equation <span class="scholmd-crossref"><span class="math scholmd-math-inline">\(\eqref{eq:continuityDeviatoricStress}\)</span></span> into it 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation*}
\begin{aligned}
\hat{f}_{\alpha}^{c} &amp;= f_{\alpha}^{(eq,c)} + \frac{\tau_c - 1}{\tau_c}  f_{\alpha}^{(neq,c)} \\
&amp;= f_{\alpha}^{(eq,f)} + \frac{\tau_c - 1}{\tau_c}  f_{\alpha}^{(neq,c)} \\
&amp;= f_{\alpha}^{(eq,f)} + m \frac{\tau_c - 1}{\tau_f}  f_{\alpha}^{(neq,f)} \\
&amp;= f_{\alpha}^{(eq,f)} + m \frac{\tau_c - 1}{\tau_f} \frac{\tau_f}{\tau_f - 1} \left [ \hat{f}_{\alpha}^{f} - f_{\alpha}^{(eq,f)} \right ]
\end{aligned}
\end{equation*}
\]</span>
 This kind of jumping around with algebra essentially allows us to write the post collision directional density on the coarse grid <span class="math scholmd-math-inline">\(\hat{f}_{\alpha}^{c}\)</span> in terms of the equilibrium <span class="math scholmd-math-inline">\(f_{\alpha}^{eq,f}\)</span> and post collision directional density <span class="math scholmd-math-inline">\(\hat{f}_{\alpha}^{f}\)</span> on the fine grid. 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation}
\label{eqfineToCoarseDD}
\rightarrow \hat{f}_{\alpha}^{c} = f_{\alpha}^{(eq,f)} + m \frac{\tau_c - 1}{\tau_f - 1} \left [ \hat{f}_{\alpha}^{f} - f_{\alpha}^{(eq,f)} \right ]
\end{equation}
\]</span>
 Doing a similar algebraic manipulation the other way around, 
<span class="math scholmd-math-display" style="display: block;">\[
\begin{equation}
\label{eq:coarseToFineDD}
\hat{f}_{\alpha}^{f} = f_{\alpha}^{(eq,f)} + \frac{1}{m} \frac{\tau_f - 1}{\tau_c - 1} \left [ \hat{f}_{\alpha}^{c} - f_{\alpha}^{(eq,c)} \right ]
\end{equation}
\]</span>
 Equations <span class="scholmd-crossref"><span class="math scholmd-math-inline">\(\eqref{eq:rhoVContinuityInterface}\)</span></span>, <span class="scholmd-crossref"><span class="math scholmd-math-inline">\(\eqref{eqfineToCoarseDD}\)</span></span> and <span class="scholmd-crossref"><span class="math scholmd-math-inline">\(\eqref{eq:coarseToFineDD}\)</span></span> are used to make an algorithm for LBM with multiple grids</p>
<h2 id="an-algorithm-for-lbm-with-multiple-grids">An algorithm for LBM with multiple grids</h2>
<p>Figure <span class="scholmd-crossref"><a href="#fig:coarseToFineGridAlgorithm">(4)</a></span> shows the LBM Algorithm using multiple grids as described by Wang et. al. <span class="scholmd-citation" data-cites="Wang2010">[4]</span>. The essential steps are as follows and correlate with the darkened arrows and numbers in the figure.</p>
<ol type="1">
<li>Begin with a collision step on the coarse grid.</li>
<li>Interpolate the post-collision directional densities to the fine grid using Equation <span class="scholmd-crossref"><span class="math scholmd-math-inline">\(\eqref{eq:coarseToFineDD}\)</span></span>. Perform a series of <span class="math scholmd-math-inline">\(m\)</span> streaming and collision steps on the fine grid.</li>
</ol>
<ul>
<li>This starts from the streaming step at time <span class="math scholmd-math-inline">\(t = (n - 1 + \frac{1}{m}) \delta t_c\)</span>. This is basically <span class="math scholmd-math-inline">\(\delta t_c/m\)</span> coarse grid time steps after the <span class="math scholmd-math-inline">\(n^{th}\)</span> time step.</li>
<li>This ends with the collision step at time <span class="math scholmd-math-inline">\(t = (n + \frac{1}{m}) \delta t_c\)</span>. This is basically <span class="math scholmd-math-inline">\(\delta t_c/m\)</span> coarse grid time steps after the <span class="math scholmd-math-inline">\((n+1)^{th}\)</span> time step.</li>
</ul>
<ol start="3" type="1">
<li>Interpolate the post-collision directional densities to the coarse grid using Equation <span class="scholmd-crossref"><span class="math scholmd-math-inline">\(\eqref{eqfineToCoarseDD}\)</span></span>.</li>
<li>Perform a streaming step on the coarse grid to reach the <span class="math scholmd-math-inline">\((n+1)^{th}\)</span> time step.</li>
</ol>
<figure class="scholmd-float scholmd-figure" id="fig:coarseToFineGridAlgorithm">
<div class="scholmd-float-content"><figure class="scholmd-subfig" style="display: inline-block; width: 75%">
<img src="./Figures/coarseToFineGridAlgorithm.png" />
</figure></div>
<div class="scholmd-float-caption"><figcaption><span class="scholmd-caption-head"><span class="scholmd-caption-head-prefix">Figure</span><span class="scholmd-caption-head-label">4</span></span><span class="scholmd-caption-text">LBM Algorithm using multiple grids as shown in Wang et. al. <span class="scholmd-citation" data-cites="Wang2010">[4]</span></span></figcaption></div>
</figure>
<p>Yu et. al. comment that</p>
<blockquote>
<p>Generally speaking, it is difficult to maintain simultaneously the continuity of mass, momentum, and stresses across the interface between neighboring blocks because interpolations are applied to each dependent variable. In the present multi-block LBE method, the continuities of mass and stresses are ensured through … The most important point is that interpolations are only applied to <span class="math scholmd-math-inline">\(f_i\)</span>’s along the interface and this automatically ensures consistency in the transfer of various terms across the interface.</p>
</blockquote>
<h2 id="calculation-of-scalar-flux-at-the-boundary">Calculation of scalar flux at the boundary</h2>
<p>The method described in Sec. (#scalarFluxCalc) is extended to the multi-block algorithm to calculate the mass flux across the boundary. The mass flux is calculated separately on the two meshes and added up. There are a couple of issues however.</p>
<ol type="1">
<li><p>It is possible to double count the mass flux if the domain boundary passes through the overlap region between the two meshes. To avoid this, one idea is to calculate the mass flux on the coarse mesh first and then on the fine mesh. When calculating the mass flux on the coarse mesh, the fine mesh nodes that intersect with the volume surrounding a coarse mesh node will be marked depending on the degree of the overlap in the volume. Thus, when calculating the mass flux from the fine mesh, the calculated flux from each node will be reduced based on the degree of overlap with any coarse mesh node that is also adjacent to the boundary. For this to work, I have to make sure that each fine mesh node will overlap with the volume around only one coarse mesh node adjacent to the boundary.</p></li>
<li><p>The mass flux from the fine mesh has to be summed up over one coarse mesh time step and recorded. The mass flux variable should be zeroed out only at the beginning of the coarse mesh time step.</p></li>
</ol>
<div class="references">
<h1 id="references" class="unnumbered">References</h1>
<p>1. Gombosi TI (1994) Gaskinetic theory. Cambridge Academic.</p>
<p>2. Sukop MC, Thorne Jr DT (2006) Lattice boltzmann modeling - an introduction for geoscientists and engineers. Springer.</p>
<p>3. Nourgaliev R, Dinh T, Theofanous T, Joseph D (2003) The lattice boltzmann equation method: Theoretical interpretation, numerics and implications. International Journal of Multiphase Flow 29: 117–169. Available: <a href="http://www.sciencedirect.com/science/article/pii/S0301932202001088" class="uri">http://www.sciencedirect.com/science/article/pii/S0301932202001088</a>.</p>
<p>4. Wang Y, Brasseur JG, Banco GG, Webb AG, Ailiani AC, et al. (2010) A multiscale lattice boltzmann model of macro- to micro-scale transport, with applications to gut function. Philosophical transactions Series A, Mathematical, physical, and engineering sciences 368: 2863–2880. Available: <a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3263792/" class="uri">http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3263792/</a>.</p>
<p>5. Banco G (2010) Multi-scale fluid mechanics of nutrient absorption in the small intestine analyzed with 2D and 3D lattice boltzmann models [PhD thesis]. Pennsylvania State University.</p>
<p>6. Yu D, Mei R, Shyy W (2002) A multi-block lattice boltzmann method for viscous fluid flows. International Journal for Numerical Methods in Fluids 39: 99–120. Available: <a href="http://dx.doi.org/10.1002/fld.280" class="uri">http://dx.doi.org/10.1002/fld.280</a>.</p>
</div>
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
      processClass: "math"
    },
    TeX: {
        TagSide: "left",
        TagIndent: "1.2em",
        equationNumbers: {
            autoNumber: "AMS"
        },
        Macros: {
            ensuremath: ["#1",1],
            textsf: ["\\mathsf{\\text{#1}}",1],
            texttt: ["\\mathtt{\\text{#1}}",1]
        }
    },
    "HTML-CSS": { 
        scale: 100,
        availableFonts: ["TeX"], 
        preferredFont: "TeX",
        webFont: "TeX",
        imageFont: "TeX",
        EqnChunk: 1000
    }
});
</script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full" type="text/javascript"></script>
</div>
</body>
</html>
